Vertices:<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 1 ~> HOLE ; ~> ((int critical1) ;)
                   ((critical1 = 0) ;) ~> ((int critical2) ;) ((critical2 = 0)
                   ;) ~> (int peterson1) ( .Decls ) { (while ( true ) ({ ((((
                  while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn =
                   2) ;)) ((critical1 = 0) ;)) })) } ~> (int peterson2) ( 
                  .Decls ) { (while ( true ) ({ ((((while ( (! (turn == 2)) ) 
                  { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;
                  )) })) } ~> (int main) ( .Decls ) { ((std::thread t1 ( 
                  peterson1 , '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 
                  , '.Exps(.KList) ) ;)) } ~> execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> ((int critical2) ;)
                   ((critical2 = 0) ;) ~> (int peterson1) ( .Decls ) { (while 
                  ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 =
                   1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })) } ~> (int 
                  peterson2) ( .Decls ) { (while ( true ) ({ ((((while ( (! (
                  turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) })) } ~> (int main) ( .Decls ) { ((
                  std::thread t1 ( peterson1 , '.Exps(.KList) ) ;) (
                  std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) } ~> 
                  execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> (int peterson1) ( 
                  .Decls ) { (while ( true ) ({ ((((while ( (! (turn == 1)) ) 
                  { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;
                  )) })) } ~> (int peterson2) ( .Decls ) { (while ( true ) ({ 
                  ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) })) } ~> (int main) ( 
                  .Decls ) { ((std::thread t1 ( peterson1 , '.Exps(.KList) ) ;
                  ) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) } ~> 
                  execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(6) )) ) ~> HOLE ( '.Exps(.KList) 
                  ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t1 ( peterson1 , '.Exps(.KList) ) ; ~> 
                  std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(4) )) ) ~> HOLE ( '.Exps(.KList) 
                  ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 2 ~> HOLE ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(5) )) ) ~> HOLE ( '.Exps(.KList) 
                  ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 1 ~> HOLE ; ~> (turn = 1) ; ~> (
                  critical2 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 1 ~> HOLE ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 2 ~> HOLE ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 1 ~> HOLE ; ~> (turn = 1) ; ~> (
                  critical2 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 1 ~> HOLE ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>
Edges:
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 1 ~> HOLE ; ~> ((int critical1) ;)
                   ((critical1 = 0) ;) ~> ((int critical2) ;) ((critical2 = 0)
                   ;) ~> (int peterson1) ( .Decls ) { (while ( true ) ({ ((((
                  while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn =
                   2) ;)) ((critical1 = 0) ;)) })) } ~> (int peterson2) ( 
                  .Decls ) { (while ( true ) ({ ((((while ( (! (turn == 2)) ) 
                  { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;
                  )) })) } ~> (int main) ( .Decls ) { ((std::thread t1 ( 
                  peterson1 , '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 
                  , '.Exps(.KList) ) ;)) } ~> execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> ((int critical2) ;)
                   ((critical2 = 0) ;) ~> (int peterson1) ( .Decls ) { (while 
                  ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 =
                   1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })) } ~> (int 
                  peterson2) ( .Decls ) { (while ( true ) ({ ((((while ( (! (
                  turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) })) } ~> (int main) ( .Decls ) { ((
                  std::thread t1 ( peterson1 , '.Exps(.KList) ) ;) (
                  std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) } ~> 
                  execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> ((int critical2) ;)
                   ((critical2 = 0) ;) ~> (int peterson1) ( .Decls ) { (while 
                  ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 =
                   1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })) } ~> (int 
                  peterson2) ( .Decls ) { (while ( true ) ({ ((((while ( (! (
                  turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) })) } ~> (int main) ( .Decls ) { ((
                  std::thread t1 ( peterson1 , '.Exps(.KList) ) ;) (
                  std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) } ~> 
                  execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> (int peterson1) ( 
                  .Decls ) { (while ( true ) ({ ((((while ( (! (turn == 1)) ) 
                  { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;
                  )) })) } ~> (int peterson2) ( .Decls ) { (while ( true ) ({ 
                  ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) })) } ~> (int main) ( 
                  .Decls ) { ((std::thread t1 ( peterson1 , '.Exps(.KList) ) ;
                  ) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) } ~> 
                  execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> (int peterson1) ( 
                  .Decls ) { (while ( true ) ({ ((((while ( (! (turn == 1)) ) 
                  { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;
                  )) })) } ~> (int peterson2) ( .Decls ) { (while ( true ) ({ 
                  ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) })) } ~> (int main) ( 
                  .Decls ) { ((std::thread t1 ( peterson1 , '.Exps(.KList) ) ;
                  ) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) } ~> 
                  execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(6) )) ) ~> HOLE ( '.Exps(.KList) 
                  ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(6) )) ) ~> HOLE ( '.Exps(.KList) 
                  ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t1 ( peterson1 , '.Exps(.KList) ) ; ~> 
                  std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t1 ( peterson1 , '.Exps(.KList) ) ; ~> 
                  std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(4) )) ) ~> HOLE ( '.Exps(.KList) 
                  ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(4) )) ) ~> HOLE ( '.Exps(.KList) 
                  ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 2 ~> HOLE ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 2 ~> HOLE ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                std::thread t2 ( peterson2 , '.Exps(.KList) ) ; ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(5) )) ) ~> HOLE ( '.Exps(.KList) 
                  ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(5) )) ) ~> HOLE ( '.Exps(.KList) 
                  ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 1 ~> HOLE ; ~> (turn = 1) ; ~> (
                  critical2 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 1 ~> HOLE ; ~> (turn = 1) ; ~> (
                  critical2 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 1 ~> HOLE ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 1 ~> HOLE ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 2 ~> HOLE ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 2 ~> HOLE ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 1 ~> HOLE ; ~> (turn = 1) ; ~> (
                  critical2 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 1 ~> HOLE ; ~> (turn = 1) ; ~> (
                  critical2 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 1 ~> HOLE ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 1 ~> HOLE ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 1 ~> HOLE ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 1 ~> HOLE ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 1
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 1 ~> HOLE ; ~> (turn = 2) ; ~> (
                  critical1 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
                  critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 2 ~> HOLE ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(1) )) = 2 ~> HOLE ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 1
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 2 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 2)) ) { })) }) else { } ~> (critical2 = 
                  1) ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) (
                  (turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 1 ~> HOLE ; ~> (turn = 1) ; ~> (
                  critical2 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Rule labelled 'update [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(2) )) = 0 ~> HOLE ; ~> while ( true ) ({ (
                  (((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 1 ~> HOLE ; ~> (turn = 1) ; ~> (
                  critical2 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 1
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 1 ~> HOLE ; ~> (turn = 1) ; ~> (
                  critical2 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 1 ~> HOLE ; ~> (turn = 1) ; ~> (
                  critical2 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "" ))
        ListItem(#istream ( 0 ))
    </in>
    <out>
        ListItem(#ostream ( 1 ))
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                (lval ( #symLoc(3) )) = 1 ~> HOLE ; ~> (turn = 1) ; ~> (
                  critical2 = 0) ; ~> while ( true ) ({ ((((while ( (! (turn 
                  == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
                  critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                rvalue ( (lval ( #symLoc(1) )) ) ~> HOLE == 1 ~> rvalue ( 
                  HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( HOLE ) ({ ({ } (
                  while ( (! (turn == 1)) ) { })) }) else { } ~> (critical1 = 
                  1) ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( true ) 
                  ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) (
                  (turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
                  
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symLoc(2) critical2 |-> #symLoc(3) 
                  main |-> #symLoc(6) peterson1 |-> #symLoc(4) peterson2 |-> 
                  #symLoc(5) turn |-> #symLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symLoc(2)
                critical2 |-> #symLoc(3)
                main |-> #symLoc(6)
                peterson1 |-> #symLoc(4)
                peterson2 |-> #symLoc(5)
                turn |-> #symLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symLoc(1) |-> 2
        #symLoc(2) |-> 0
        #symLoc(3) |-> 0
        #symLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 
          = 0) ;)) })) )
        #symLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (! (
          turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 
          = 0) ;)) })) )
        #symLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , '.Exps
          (.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) )
          
    </store>
    <genv>
        critical1 |-> #symLoc(2)
        critical2 |-> #symLoc(3)
        main |-> #symLoc(6)
        peterson1 |-> #symLoc(4)
        peterson2 |-> #symLoc(5)
        turn |-> #symLoc(1)
    </genv>
</T>] 
