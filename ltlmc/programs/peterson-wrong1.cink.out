Vertices:<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 1 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> ((int critical1) ;) ((critical1 = 0) ;) ~> ((
                  int critical2) ;) ((critical2 = 0) ;) ~> (int peterson1) ( 
                  .Decls ) { (while ( true ) ({ ((((while ( (! (turn == 1)) ) 
                  { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;
                  )) })) } ~> (int peterson2) ( .Decls ) { (while ( true ) ({ 
                  ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) })) } ~> (int main) ( 
                  .Decls ) { ((std::thread t1 ( peterson1 , '.Exps(.KList) ) ;
                  ) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) } ~> 
                  execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 0 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> ((int critical2) ;) ((critical2 = 0) ;) ~> (
                  int peterson1) ( .Decls ) { (while ( true ) ({ ((((while ( (
                  ! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) (
                  (critical1 = 0) ;)) })) } ~> (int peterson2) ( .Decls ) { (
                  while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })) 
                  } ~> (int main) ( .Decls ) { ((std::thread t1 ( peterson1 , 
                  '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(
                  .KList) ) ;)) } ~> execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> (int peterson1) ( .Decls ) { (while ( true ) (
                  { ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) })) } ~> (int peterson2) 
                  ( .Decls ) { (while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) })) } ~> (int main) ( .Decls ) { ((std::thread t1 ( 
                  peterson1 , '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 
                  , '.Exps(.KList) ) ;)) } ~> execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(6) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(4) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(5) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(5) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 1 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1
                  ) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 2 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical1 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn =
                   2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 0 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 1)) 
                  ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 1 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1
                  ) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 1 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical2 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn =
                   1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 1 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1
                  ) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 2 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical1 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn =
                   2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>
Edges:
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 1 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> ((int critical1) ;) ((critical1 = 0) ;) ~> ((
                  int critical2) ;) ((critical2 = 0) ;) ~> (int peterson1) ( 
                  .Decls ) { (while ( true ) ({ ((((while ( (! (turn == 1)) ) 
                  { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;
                  )) })) } ~> (int peterson2) ( .Decls ) { (while ( true ) ({ 
                  ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((
                  turn = 1) ;)) ((critical2 = 0) ;)) })) } ~> (int main) ( 
                  .Decls ) { ((std::thread t1 ( peterson1 , '.Exps(.KList) ) ;
                  ) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;)) } ~> 
                  execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 0 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> ((int critical2) ;) ((critical2 = 0) ;) ~> (
                  int peterson1) ( .Decls ) { (while ( true ) ({ ((((while ( (
                  ! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) (
                  (critical1 = 0) ;)) })) } ~> (int peterson2) ( .Decls ) { (
                  while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })) 
                  } ~> (int main) ( .Decls ) { ((std::thread t1 ( peterson1 , 
                  '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(
                  .KList) ) ;)) } ~> execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 0 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> ((int critical2) ;) ((critical2 = 0) ;) ~> (
                  int peterson1) ( .Decls ) { (while ( true ) ({ ((((while ( (
                  ! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) (
                  (critical1 = 0) ;)) })) } ~> (int peterson2) ( .Decls ) { (
                  while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })) 
                  } ~> (int main) ( .Decls ) { ((std::thread t1 ( peterson1 , 
                  '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(
                  .KList) ) ;)) } ~> execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> (int peterson1) ( .Decls ) { (while ( true ) (
                  { ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) })) } ~> (int peterson2) 
                  ( .Decls ) { (while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) })) } ~> (int main) ( .Decls ) { ((std::thread t1 ( 
                  peterson1 , '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 
                  , '.Exps(.KList) ) ;)) } ~> execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> (int peterson1) ( .Decls ) { (while ( true ) (
                  { ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((
                  turn = 2) ;)) ((critical1 = 0) ;)) })) } ~> (int peterson2) 
                  ( .Decls ) { (while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) })) } ~> (int main) ( .Decls ) { ((std::thread t1 ( 
                  peterson1 , '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 
                  , '.Exps(.KList) ) ;)) } ~> execute
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
    </store>
    <genv>
        .Map
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(6) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(6) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                noName
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(4) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(5) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(4) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(5) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(5) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(5) ) ~> rvalue ( HOLE ) ~> HOLE ( 
                  '.Exps(.KList) ) ~> HOLE ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                .List
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 1 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1
                  ) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 1 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1
                  ) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 2 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical1 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn =
                   2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 2 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical1 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn =
                   2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 0 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 1)) 
                  ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 0 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 1)) 
                  ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 1 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1
                  ) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 1 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1
                  ) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 1 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical2 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn =
                   1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 1 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical2 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn =
                   1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 1 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1
                  ) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 1 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1
                  ) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 2 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical1 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn =
                   2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 2 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical1 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn =
                   2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 2 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical1 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn =
                   2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 2 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical1 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn =
                   2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 0 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 1)) 
                  ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 0 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 1)) 
                  ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 1 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1
                  ) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 1 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> (turn = 1) ; ~> (critical2 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 2)) ) { }) ((critical2 = 1
                  ) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 1 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical2 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn =
                   1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 1 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical2 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn =
                   1) ;)) ((critical2 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 2
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(3) , 0 ) ~> lval ( #symScalLoc(3) )
                   ~> HOLE ; ~> while ( true ) ({ ((((while ( (! (turn == 2)) 
                  ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0)
                   ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 1
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 1
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 1)) ) { })) }) else { }
                   ~> (critical1 = 1) ; ~> (turn = 2) ; ~> (critical1 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 1)) ) { }) ((
                  critical1 = 1) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 1 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1
                  ) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
Unlabelled rule [<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(2) , 1 ) ~> lval ( #symScalLoc(2) )
                   ~> HOLE ; ~> (turn = 2) ; ~> (critical1 = 0) ; ~> while ( 
                  true ) ({ ((((while ( (! (turn == 1)) ) { }) ((critical1 = 1
                  ) ;)) ((turn = 2) ;)) ((critical1 = 0) ;)) }) ~> return 
                  noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 0
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>,<T>
    <in>
        ListItem(#buffer ( "\n" ))
    </in>
    <out>
        ListItem(#buffer ( "" ))
    </out>
    <threads>
        <thread>
            <k>
                $update ( #symScalLoc(1) , 2 ) ~> lval ( #symScalLoc(1) )
                   ~> HOLE ; ~> (critical1 = 0) ; ~> while ( true ) ({ ((((
                  while ( (! (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn =
                   2) ;)) ((critical1 = 0) ;)) }) ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t1
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
        <thread>
            <k>
                $lookup ( #symScalLoc(1) ) ~> rvalue ( HOLE ) ~> HOLE == 2
                   ~> rvalue ( HOLE ) ~> ! HOLE ~> rvalue ( HOLE ) ~> if ( 
                  HOLE ) ({ ({ } (while ( (! (turn == 2)) ) { })) }) else { }
                   ~> (critical2 = 1) ; ~> (turn = 1) ; ~> (critical2 = 0) ;
                   ~> while ( true ) ({ ((((while ( (! (turn == 2)) ) { }) ((
                  critical2 = 1) ;)) ((turn = 1) ;)) ((critical2 = 0) ;)) })
                   ~> return noVal ;
            </k>
            <return>
                .K
            </return>
            <name>
                t2
            </name>
            <fstack>
                ( ([ critical1 |-> #symScalLoc(2) critical2 |-> 
                  #symScalLoc(3) main |-> #symScalLoc(6) peterson1 |-> 
                  #symScalLoc(4) peterson2 |-> #symScalLoc(5) turn |-> 
                  #symScalLoc(1) ]) , HOLE ; )
            </fstack>
            <sideEffects>
                .Bag
            </sideEffects>
            <env>
                critical1 |-> #symScalLoc(2)
                critical2 |-> #symScalLoc(3)
                main |-> #symScalLoc(6)
                peterson1 |-> #symScalLoc(4)
                peterson2 |-> #symScalLoc(5)
                turn |-> #symScalLoc(1)
            </env>
        </thread>
    </threads>
    <store>
        #symScalLoc(1) |-> 1
        #symScalLoc(2) |-> 1
        #symScalLoc(3) |-> 0
        #symScalLoc(4) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 1)) ) { }) ((critical1 = 1) ;)) ((turn = 2) ;)) ((
          critical1 = 0) ;)) })) )
        #symScalLoc(5) |-> lambda ( .Decls @ (while ( true ) ({ ((((while ( (!
           (turn == 2)) ) { }) ((critical2 = 1) ;)) ((turn = 1) ;)) ((
          critical2 = 0) ;)) })) )
        #symScalLoc(6) |-> lambda ( .Decls @ ((std::thread t1 ( peterson1 , 
          '.Exps(.KList) ) ;) (std::thread t2 ( peterson2 , '.Exps(.KList) ) ;
          )) )
    </store>
    <genv>
        critical1 |-> #symScalLoc(2)
        critical2 |-> #symScalLoc(3)
        main |-> #symScalLoc(6)
        peterson1 |-> #symScalLoc(4)
        peterson2 |-> #symScalLoc(5)
        turn |-> #symScalLoc(1)
    </genv>
</T>] 
