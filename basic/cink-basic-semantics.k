require "cink-basic-syntax.k"

module CINK-BASIC-SEMANTICS
  imports CINK-BASIC-SYNTAX


  /*@ \subsection{Memory Model}
   We use an abstract memory model consisting of (automatically generated) \
   symbolic values for locations. 
   The locations are splitted in two categories: scalar locations, which can 
   store scala values, and compound locations, which can store values of
   compound types.
   A location is identified with its address.
   These sort for locations is \texttt{Loc} and that for scalar locations is
   \texttt{ScalLoc}. We use a special constant \texttt{noLoc}
   for non-defined locations. The locations are used as values for pointer
   types and therefore they are subsodrted to \texttt{ScalVal}.
   */


  syntax ScalLoc ::= "noLoc"
  syntax Loc ::= ScalLoc
  syntax ScalVal ::= Loc

  /*@ \subsubsection{Memmory operations and side-effects} */

  /*@
   The memory operations and the side effects are described by internal
   operations whose semantics is self explained.
  */

  syntax Exp ::= "$inc" "(" K "," ScalVal ")"
               | "$dec" "(" K "," ScalVal ")"
               | "$update" "(" K "," Val ")" [strict(1(result(Loc)))]
               | "$lookup" "(" K ")"



  rule <k> $inc(L:ScalLoc, V:Int) => . ...</k>
       <store>... L |-> (V':Int => V' +Int V) ...</store>
       [kripke(inc)]


  rule <k> $dec(L:ScalLoc, V:Int) => . ...</k>
       <store>... L |-> (V':Int => V' -Int V) ...</store>
       [kripke(dec)]


  rule <k> $update(L:ScalLoc, V:ScalVal) => . ...</k>
       <store>... L |-> (_ => V) ...</store>
       [kripke(update)]


  rule <k> $lookup(L:ScalLoc) => V ...</k>
       <store>... L |-> V:ScalVal ...</store>
       [kripke(mem-lookup)]

  /*@ \subsection{Values.} 
    The values are a very important syntactic category in the definition
    of any language; with them, we are able to know when the evaluation
    of an expression is finished. This piece of information is crucial
    for the heating and cooling rules. 

    In order to keep the definition
    as simple as possible, we let the expressions be evaluated always
    to lvalues and then use the context \texttt{rvalue} to convert them into 
    rvalues whenever this is needed. To be more precise, we consider the
    example of the
    expression \texttt{++x + y}. According to \Cpp semantics, the evaluation
    of the operator \texttt{++} returns an lvalue. When  the operator
    \texttt{+} is evaluated this must be converted into an rvalue.
    Therefore the strict attribute of \texttt{+} has two sub-attributes:
    \texttt{context(rvalue)} and \texttt{result(ScalVal)}. 
    To understand better this mechanism, we present the heating/cooling
    rules generated by strict attribute for the \texttt{+} operator:
\begin{verbatim}
  E1:Exp + E2:Exp => rvalue(E1) ~> HOLE + E2 when notBool isScalVal(E1)
  E1:Exp + E2:Exp => rvalue(E2) ~> E2 + HOLE when notBool isScalVal(E2)
  I1:ScalVal ~> HOLE + E2 => I1 + E2
  I2:ScalVal ~> E1 + HOLE => E1 + I2
\end{verbatim}
    For instance, the above expression will be derived into the following
    sequence of computations (note that \texttt{rvalue} is strict, too):
\begin{verbatim}
  ++x + y => rvalue(y) ~> ++x + HOLE => y ~> rvalue(HOLE) ~> ++x + HOLE 
\end{verbatim}
    After the variable \texttt{y} is evaluated to its lvalue, it must be 
    converted to an
    rvalue. Therefore we use a label \texttt{lval($l$)} saying that the location
    $l$ plays the role of lvalue and the conversion is realised by a rule of
    the form \texttt{rvalue(lval(l)) => }\textit{the value stored at the 
    location} \texttt{l}.

    We already defined the subset of values that is part of the syntax, 
    namely the values given by the scalar types. Here we extend the set
    o values with intermediate constructs needed to execute programs. 
    Such a value is\texttt{noVal}, which "paradoxically" denotes in fact 
    "no value". The lambda abstractions are used for storing the
    functions. Similar to other \K examples (IMP, IMP++, SIMPLE), the 
    functions are stored similar to variables and therefore their definitions
    are seen as values. Since they cannot split into sub-values, we define
    them as scalar values.
   */


  syntax ScalVal ::= "noVal" 
               | "lambda" "(" Decls "@" Stmts ")" 
                 [latex(\lambda\,{#1}\mathrel{\bullet}{#2})]

  syntax Val ::= lval(Loc)

  //@ The empty expression is a value as well:

  rule isVal(.Exps) => true

  //@ Any value is a K result:
  syntax KResult ::= Val

  //@ The definition of the strict context \texttt{rvalue}:
  
  syntax Exp ::= "rvalue" "(" Exp ")" [context(result(Val)), 
                                       strict, klabel(rvalue)]

  /*@
    When an lvalue is in an rvalue context, evaluate it (this can be seen 
    as a conversio from lvalues to rvalues):
   */

  rule rvalue(lval(L:Loc) => $lookup(L))


  /*@ \subsection{ Seqpoints}
    The semantics of a sequence point consists of executing all the side effects
    collected in the evaluation of the current expression. This is required,
    e.g., by the complete evaluation of a full expression and the comma
    operator.
    So, the semantical statement "seqpoint" has the role to check that the all
    side effects are executed, i.e. the cell \textsf{sideEffects} is empty.
  */

  syntax K ::= "seqpoint"

  rule [seqpoint] :
       <k> seqpoint => . ...</k>
       <sideEffects> . </sideEffects>
       [seqpoint]

  /*@
   The side effects can be also executed concurrently with the other
   evaluation steps of the current expression:
  */

  rule [side-effect] :
       <k> . => SE ...</k>
       <sideEffects>...  <sideEffect> SE </sideEffect> => . ... </sideEffects>
       [side-effect]

  /*@ \subsection{Auxiliary constructs.} */


  /*@
    \texttt{execute} is used to start the computation of a program; and
    \texttt{noname} for the initial name of a thread.
  */
  syntax K ::= "execute"

 /*@
   The next two constructors are used for storing the environment and the
   rest of the computation in the call stack (\texttt{fstack}). 
 */

  syntax ListItem ::= "(" List "," K ")"
                    | "[" Map "]"

  /*@
    \subsection{Desugaring}
    In order to have a minimal set of rules, some syntactic constructs
    are desugared. 
   */

  /*@ The desugaring rule for the if-then statement: */
  rule if(B:Exp) St:Stmt => if(B) St else {}  [macro]
  
  /*@
    The desugaring rule for statements declaring multiple variables.
   */

  rule T:Type (E:Exp, E':Exp) ; => T E; T E'; [macro]

 /*@
    Desugaring rule for variable declarations with initialization.
    In this iterartion only variables of fundamental types can be
    initialized.
  */

   rule T:FundType E1:Exp = E2:Exp ; => T E1; getName(E1) = E2;
        [macro]


  /*@ \subsection{Declarations.} */

  /*@
    Function declaration: a function is a stored similar to a variable,
    where the value stored in the associated location is the lambda
    abstraction of the function. 
   */


  rule <k>  (Decl:Decl (Xl:Decls) {Sts:Stmts})::Stmt  => .  ...</k> 
       <env>... . =>  (getName(Decl) |-> L) ...</env>
       <store>... . => (L |-> lambda(Xl @ Sts)) ...</store>
       requires fresh(L:ScalLoc)
       [fun-decl, structural]

  /*@
    The rules for variable declarations for the fundamental types:\\
    From the \Cpp manual (6.7):
    \begin{quote}
    The zero-initialization (8.5) of all block-scope variables with static 
    storage duration (3.7.1) or thread storage
    duration (3.7.2) is performed before any other initialization takes place.
    \end{quote}
    From the \Cpp manual (8.5):
    \begin{quote}
    To zero-initialize an object or reference of type T means:\\
     - if T is a scalar type (3.9), the object is set to the value 0 (zero), 
    taken as an integral constant expression,
    converted to T;
    \end{quote}
    In this iteration the values and expressions are not typed, 
    so the conversion cannot be defined.
   */

  rule [var-decl] :
       <k> T:ScalType X:Id; => .  ...</k>      
       <env> Env:Map => Env[L/X] </env>
       <store>... . => (L |-> 0) ...</store>
  requires fresh(L:ScalLoc)
       [structural]


  /*@ The following two constructs have no semantics yet;
      they are used now only  for having a full compatibility with \Cpp,
      e.g., the \Cink programs can be 
      compiled with a \Cpp compiler. */
  rule #include <iostream> => . 
       [include, structural]

  rule using namespace std;=> .
       [using, structural]

  /*@ 
    The auxiliary construct \texttt{execute} is used to initialize the 
    execution of a program, which for the case of \Cink consists of the call
    of the main function.
  */

  rule <k> execute => String2Id("main")(.Exps); </k>
       <env> Env:Map </env>
       <genv> . => Env:Map </genv>
       [main, structural]
  
  /*@ \subsection{Expressions Evaluation.} */

  /*@
   
   The following expressions are strict and therefore their semantics
   is given only for the case the operands are values.  
  */
  rule I1:Int + I2:Int => I1 +Int I2 [plus]

  rule I1:Int - I2:Int => I1 -Int I2 

  rule I1:Int * I2:Int => I1 *Int I2

  rule I1:Int / I2:Int => I1 /Int I2 requires I2 =/=Int 0
 
  rule I1:Int % I2:Int => I1 %Int I2 requires I2 =/=Int 0

  rule I1:Int < I2:Int => (I1 <Int I2)

  rule I1:Int > I2:Int => (I1 >Int I2)

  rule I1:Int <= I2:Int => (I1 <=Int I2)

  rule I1:Int != I2:Int => (I1 =/=Int I2)

  rule I1:Int == I2:Int => (I1 ==Int I2)
 
  rule true && B:Exp => B
  rule false && B:Exp => false
  rule true || B:Exp => true
  rule false || B:Exp => B 
  rule ! false  => true
  rule ! true => false 

  rule endl => "\n" 

  /*@ \subsubsection{The prefix increment/decrement operator}
 Here is the description of the the prefix increment from the \Cpp manual:
\begin{quote}
The operand of prefix ++ is modified by adding 1, or set to true if it is 
bool (this use is deprecated). The operand shall be a modifiable lvalue. 
The type of the operand shall be an arithmetic type or a pointer to
a completely-defined object type. The result is the updated operand; 
it is an lvalue, and it is a bit-field if
the operand is a bit-field. If x is not of type bool, the expression ++x is 
equivalent to x+=1 
[ Note: See the discussions of addition (5.7) and assignment operators (5.17) 
for information on conversions.]
\end{quote}
  The semantics consists of executing the corresponding side effect and returning 
  the involved location:
  */

  rule ++ lval(L:Loc) => $inc(L, 1) ~> lval(L)

  rule -- lval(L:Loc) => $dec(L, 1) ~> lval(L)


  /*@
  \subsubsection{The postfix increment/decrement operator}
   Here is the description of this operator from the manual of 
  \Cpp 2011 (5.2.6):
\begin{quote}
  The value of a postfix ++ expression is the value of its operand.
  [ Note: the value obtained is a copy of
  the original value -end note ] The operand shall be a modifiable lvalue.
  The type of the operand shall be an arithmetic type or a pointer to a
  complete object type. The value of the operand object is modified by
  adding 1 to it, unless the object is of type bool, in which case it is set
  to true. [ Note: this use is deprecated, see Annex D. -end note ]
  The value computation of the ++ expression is sequenced before the
  modification of the operand object. \ldots The result is a prvalue.
\end{quote}
  From the Appendix D: 
\begin{quote}
  D.1 The use of an operand of type bool with the ++ operator is deprecated 
  (see 5.3.2 and 5.2.6)."
\end{quote}
  */


  
  /*@
    We add a new cell that collects the side-effects during the evaluation
    of a full-expression. 
    Therefore the result value is the 
    value  stored at the computed location and its side-effect is added to 
    the cell with the side-effects. Note that we have a kind of lvalue to
    rvalue conversion here.
  */


  rule [postinc]:
       <k> lval(L:ScalLoc) ++ => V ...</k>
       <store>... L |-> V:ScalVal ...</store>
       <sideEffects>...
          . => <sideEffect> $inc(L,1) </sideEffect> 
       ...</sideEffects>


  rule [postdec]:
       <k> lval(L:ScalLoc) -- => V ...</k>
       <store>... L |-> V:ScalVal ...</store>
       <sideEffects>...
          . => <sideEffect> $dec(L,1) </sideEffect>
       ...</sideEffects>



  /*@
    The evaluation of a variable name as an lvalue:
  */
  rule <k> X:Id => lval(L) ...</k>
       <env>... X |-> L:Loc ...</env>

  /*@
    The memory update is given by the assignment operator.
    An assignemnt, after the reduction of the arguments, has in the lef-hand
    side a location ($=$ the lvalue designated by the lhs.) and in the 
    right-hand side an rvalue.
    From \Cpp manual:
\begin{quote}
The assignment operator (=) and the compound assignment operators all group
 right-to-left. All require a modifiable lvalue as their left operand and 
return an lvalue referring to the left operand. \ldots . In all cases,
 the assignment is sequenced after the value computation of the right and 
left operands, and before the value computation of the assignment expression.
\end{quote}
  Therefore the semantics of the assign operator is similar to that of postfix
  operators.\\
  The semantics of compound assignment operators is let as exercises.
  */

  rule [update] : <k> lval(L:Loc) = V:Val => lval(L) ...</k>
       <sideEffects>...
           . =>  <sideEffect> $update(L, V) </sideEffect>
       ...</sideEffects>

/*@  The comma operator. 
    From \Cpp manual:

\begin{quote}
A pair of expressions separated by a comma is evaluated left-to-right; 
the left expression is a discarded value
expression (Clause 5). 
Every value computation and side effect associated with the left expression
is sequenced before every value computation and side effect associated with 
the right expression. The type
and value of the result are the type and value of the right operand; 
the result is of the same value category
as its right operand, \ldots. If the value of the right
operand is a temporary (12.2), the result is that temporary.
\end{quote}

  The sequenced before requirement is accomplished by adding a seqpoint:

*/

  rule V:Val,E:Exp => seqpoint ~> E

  /*@ \subsection{Control Statements.} */

  /*@
    As usual, the \texttt{while} statement is desugared using the 
    \texttt{if-then-else} statement.
  */
  rule while(B:Exp) St:Stmt => if (B) {St while(B) St} else {}
       [while, structural]

  /*@
    Since \texttt{if} is strict in the first argument, which is a boolean
    expression, proceed by case-analysis on the result values:
  */
  rule if(false) _ else St:Stmt => St [if-false]
  rule if(true) St:Stmt else _ => St [if-true]


  /*@
    The semantics of the expression statement consists of removing the
    value obtained by evaluating the expression. Recall that the statement
    is strict.\\
From the \Cpp manual:
\begin{quote}
Every value computation and side effect associated with a full-expression
is sequenced before every value computation and side effect associated with 
the next full-expression to be evaluated
\end{quote}
    We use a seqpoint in order to sequence the side effects.
   */
  rule V:Val; => seqpoint
       [instr-expr]

  /*@
    Block. Note that in this iteration we assume that the blocks do not include
    variable declarations. This will be added in a future iteration.\\
      -- the case of non-empty block
  */
  rule { Sts:Stmts } => Sts
       [block, structural]

  /*@ -- the case of the empty block: */
  rule {} => .  [block-empty, structural]

  //@ The sequential composition is just a sequence of computations:
  rule (Sts:Stmts Sts':Stmts) => (Sts ~> Sts')
       [seq-comp, structural] 

//  rule .Stmts => .K

  /*@ \subsection{Input/Output Statements.} */

  /*@ Writting in the the standard stream \texttt{cout}: */

  rule <k> cout << V:ScalVal => cout  ...</k>  
       <out>... . => ListItem(V) </out>
       [print-stream, print]

  /*@
   In order to read from the standard stream \texttt{cin}, the expression
   from the right-hand side must be evaluated to an l-value:
  */

  rule <k> cin >> lval(L:Loc) => $update(L, V) ~> cin  ...</k>
       <in> (ListItem(V:ScalVal) => .)  ...</in>
       [read-stream]


  /*@
    \subsection{The function call expression}
    The function name is evaluated to its value, which is a lambda 
    abstraction: $\it Xl$ is the list of parameters, $\it Sts$ is body of
    the function. The {\sc function-call} rule pushes the calling context,
    i.e., the remainder of the computation $K$ and environment stack 
    (including the current environment) on top of the function stack, 
    while the {\sc return} rule uses the information there to restore 
    the environment and computation of the caller.
    Since the evaluation strategy for the second argument is depending on
    the binding specification in the function signature, the function call
    expression is declared strict only in its first argument.
    Note that in this iteration we consider only the call-by-value 
    binding mechanism. The call-by-reference mechanism will be considered
    together with references in the next iteration.
  */

/*@
From the \Cpp manual:
\begin{quote}
When a function is called, each parameter (8.3.5) shall be initialized 
(8.5, 12.8, 12.1) with its corresponding
argument. [ Note: Such initializations are indeterminately sequenced with 
respect to each other (1.9) -end note ] \ldots\\  
During the initialization of a parameter, an implementation may avoid the 
construction of extra temporaries by
combining the conversions on the associated argument and/or the construction
of temporaries with thevinitialization of the parameter (see 12.2). 
The lifetime of a parameter ends when the function in which it
is defined returns. The initialization and destruction of each parameter 
occurs within the context of the calling function.
\ldots\\{}
[ Note: a function can change the values of its non-const parameters, 
but these changes cannot affect the
values of the arguments except where a parameter is of a reference 
type (8.3.2)\ldots -end note]
\end{quote}
*/

  /*@
    The rule defining the evaluation of a function call expression evaluates
    first the actual parameters, and then binds the 
    values to the formal parameters and executes the body, while saving the
    calling context in case of an abrupt return. This is done by mimic the
    heating-cooling mechanism (the first rule is a heating-like one, and the
    second a cooling-like one).
   */

  rule <k> lambda(Xl:Decls @ Sts:Stmts)(El:Exp)
           =>
           evaluate append(El,.Exps) to .Exps following Xl; ~> seqpoint ~>
           lambda(Xl:Decls @ Sts:Stmts)(HOLE)
       ...</k> 

  rule (evaluate .Exps to Vl following Xl;  ~> seqpoint)
       =>
       (seqpoint ~> evaluate .Exps to Vl following Xl;)

  rule <k> (evaluate .Exps to Vl following _; 
         ~> lambda(Xl:Decls @ Sts:Stmts)(HOLE) 
         ~> K:K)
           => 
           (bind Vl to Xl; ~> Sts ~> return noVal;)
       </k>
       <br/>
       <genv> GEnv:Map </genv>
       <env> Env:Map => GEnv </env>
       <fstack> . => ([Env], K) ...</fstack>
       [fun-call]

  /*@
    To evaluate actual parameters according to their declared strategy we will
    make use of the power of \K evaluation contexts. 
    The actual parameters must be evaluated using 
    the $\terminalNoSpace{evaluate}$ construct and $\terminalNoSpace{following}$ 
    the list of formal parameters.
  */

  syntax K ::= "evaluate" K "to" K "following" Decls ";" [evaluate]

  /*@
    For a formal parameter declared with the call-by-value mechanism,
    the corresponding argument expression must be evaluated to an rvalue as
    specified by the following contextual declaration:
  */

  context evaluate ((HOLE => rvalue(HOLE)), _:Exp) to _ 
          following (T X:Id, _:Decls); 
          [result(ScalVal)]

  /*@
    \noindent This second context uses again the special type of context used
    above for $\terminalNoSpace{evaluate}$, by requesting that the expression
    on position $\khole{}$ be evaluated as an lvalue.
    \par
    The following two rules, together with the strict evaluation strategy for
    the comma operator complete the semantics of $\terminalNoSpace{evaluate}$
    by recursing into the lists:
  */


  rule evaluate(V:Val, El => El) to (Vl => append(Vl, V))
         following (Dec:Decl, Xl:Decls => Xl);
       [structural]
   
   /*@
     \subsubsection{Binding mechanisms}
     Similarly to the evaluation rules, the binding rules are also different 
     for the two parameter passing styles.
     As we have already seen, the binding is performed using an auxiliary 
     construction:
   */

  syntax K ::= "bind" K "to" Decls ";"  

  /*@
  For call-by-value, the passed value $V$ is stored into a new memory location
  which is bound to the formal parameter:
  */
 
  rule <k> bind((V:ScalVal, Vs) => Vs)
           to((T X:Id, Xl:Decls) => Xl); 
       ...</k>
       <env> Env:Map => Env[L/X] </env>
       <store>... . => L |-> V ...</store>
       requires fresh(L:ScalLoc)
       [structural]




  /*@
    Finally, once all parameters have been bound, the binding construct 
    dissolves:
   */
  rule bind .Exps to .Decls; => . [ structural ]

  /*@
    \subsection{Function Return.} 
  */

       
  /*@
    The environment and the code are restored before returning back
    to the calling code.
    The side effects are sequenced before; this ensured by the fact the
    cell \textsf{sideEffects} is empty.
  */

  rule <k> (return V:Val; ~> _) => (V ~> K) </k>
       <env> _ => Env </env>
       <fstack> ([Env:Map], K:K) => . ...</fstack>
       <br/>
       <sideEffects> . </sideEffects>
       <return> _ => V </return>
       [return]

  /*@
    \subsection{Auxiliary Functions and Rules.}
    Here we include the semantics for the auxiliary constructs, used to give
    semnatics for \Cink.\\
  */

  /*@
    The next operator returns the variable name from an expression occurring
    in a declaration:
  */
  syntax  Id ::= "getName" "(" K ")" [function]

  rule getName(X:Id) => X
  rule getName(T:Type E:Exp) => getName(E)
  rule getName(E1:Exp = E2:Exp) => getName(E1)
  rule getName(E1:Exp,E2:Exp) => getName(E2)

  //@ Append function:

  syntax Exp ::= "append" "(" Exp "," Exp ")" [function]
  rule append((E:Exp, El:Exp), E') => E, append(El, E')
  rule append(.Exps, .Exps) => .Exps
  rule append(.Exps, E:Exp) => E,.Exps
    requires E =/=K .Exps
  rule append(E:Exp,E') => E, E' [owise]

endmodule
